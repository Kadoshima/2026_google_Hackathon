# BE-041：冪等性ロック（Firestoreトランザクションで二重実行防止）

## 担当者
- 

## 目的
同一 `analysis_id` の Worker が同時実行/再実行されても、解析本体が二重に走らないようにする。

## 全体像
- `./D-WORKER-OVERVIEW.md` を参照（Worker 全体の呼び出しチェーン）

## 完了条件（Definition of Done）
- Firestore トランザクションで lock を取得/失敗判定できる
- `READY` / `FAILED` は即スキップ扱い
- lock TTL 超過時はロック奪取（stale lock recovery）できる
- 処理終了時に lock を解放できる

## どこから呼ばれる前提か（Entry）
- `POST /internal/tasks/analysis`（BE-040） の最初で呼ばれる
- orchestrator の実行中に heartbeat/refresh を呼ぶ場合もある（任意）

## ロック対象ドキュメント
- `analyses/{analysisId}`

## 追加フィールド案
```ts
type AnalysisLockFields = {
  lockOwner?: string
  lockExpiresAt?: string // ISO8601
  lockHeartbeatAt?: string // 任意
}

// 既存の Analysis 型（src/domain/types.ts）にロック運用用の
// フィールドを追加するか、Firestore 側だけの内部フィールドとして扱う
type AnalysisWithLock = Analysis & AnalysisLockFields
```

## 判定ルール
1. `status` が `AnalysisStatus.READY` / `AnalysisStatus.FAILED` の場合: `acquired = false`（終了済み）
2. `lockOwner` が空: 取得可
3. `lockExpiresAt` が現在時刻より過去: stale とみなして取得可
4. `lockExpiresAt` が未来: 他プロセス実行中なので取得不可

## 実装対象ファイル
- `src/services/firestore.repo.ts`

## 推奨 API
```ts
acquireAnalysisLock(
  analysisId: string,
  lockOwner: string,
  ttlSec?: number
): Promise<{ acquired: boolean; reason?: string }>

releaseAnalysisLock(
  analysisId: string,
  lockOwner: string
): Promise<void>

refreshAnalysisLock(
  analysisId: string,
  lockOwner: string,
  ttlSec?: number
): Promise<void>
```

## トランザクション疑似コード
```ts
runTransaction(async (tx) => {
  const doc = await tx.get(analysisRef)
  if (!doc.exists) throw notFound

  const data = doc.data()
  if (data.status === 'READY' || data.status === 'FAILED') {
    return { acquired: false, reason: 'already_finished' }
  }

  const now = Date.now()
  const lockExpiresAt = parseTs(data.lockExpiresAt)
  const locked = data.lockOwner && lockExpiresAt && lockExpiresAt > now

  if (locked) {
    return { acquired: false, reason: 'locked' }
  }

  tx.update(analysisRef, {
    lockOwner,
    lockExpiresAt: new Date(now + ttlSec * 1000).toISOString()
  })

  return { acquired: true }
})
```

## TTL 推奨値
- 初期: `ttlSec = 300`（5分）
- 長い処理を想定するなら orchestrator 側で heartbeat/refresh（60〜120秒ごと）

## 競合・障害時の扱い
- release は「自分が owner のときだけ」消す
- release 失敗は warning ログだけで処理継続（冪等重視）
- 取得失敗はエラーではなくスキップ扱いで返す

## テスト観点
- 初回取得成功
- 同時2リクエストで片方のみ成功
- TTL 切れ後の再取得成功
- `READY`/`FAILED` のとき必ず取得失敗
- owner 不一致で release しても lock が消えない

## 作業ログ
- 
