# BE-040：POST /internal/tasks/analysis（Cloud Tasks起動）

## 担当者
- 

## 目的
Cloud Tasks から起動される Worker エンドポイントを実装し、`analysis_id` を受けて解析処理を開始できる状態にする。

## 全体像
- `./D-WORKER-OVERVIEW.md` を参照（呼ばれ方、依存関係、データフロー）

## 型定義との整合（commit: `3a13f165b4574583b10a8c1a3b608ee9eb9ba371` 反映）
- API body は `analysis_id`（snake_case）で受け取る
- ドメイン層は `analysisId`（camelCase）を使う（`Analysis.analysisId`）
- status/step/error は `Analysis` の `status/step/error` を更新する
- enum は `AnalysisStatus` / `AnalysisStep`（`src/domain/enums.ts`）を使う

## どこから呼ばれる前提か（Entry）
- 直接の呼び出し元: Cloud Tasks（BE-032）
  - `TasksService.enqueueAnalysisTask` が `/internal/tasks/analysis` に POST する
- さらに上流: `POST /v1/analyze`（BE-036）
  - `analysis_id` を採番し、enqueue する

## 完了条件（Definition of Done）
- `POST /internal/tasks/analysis` が実装されている
- request body の `analysis_id` をバリデーションして処理開始できる
- BE-041 のロック取得を呼び出して二重実行を防止できる
- 正常時は `202` を返し、失敗時は適切なエラーを返す
- ログに `analysisId` と `requestId`（または lockOwner）を出せる

## I/O 契約
### Request
```json
{
  "analysis_id": "ana_xxxxx"
}
```

### Response（正常）
```json
{
  "accepted": true,
  "analysis_id": "ana_xxxxx"
}
```

### Response（冪等でスキップ）
```json
{
  "accepted": false,
  "analysis_id": "ana_xxxxx",
  "reason": "already_processed_or_locked"
}
```

## 実装対象ファイル
- `src/routes/internal/tasks.ts`
- `src/services/analysis/orchestrator.ts`
- （必要なら）`src/utils/errors.ts`

## 実装ステップ
1. `registerTaskRoutes` で `app.post('/tasks/analysis', ...)` を追加
2. body を JSON として読み取り、`analysis_id` の存在/形式を検証
3. lockOwner を生成（例: `task-${Date.now()}` または UUID）
4. BE-041 の `acquireAnalysisLock(analysisId, lockOwner)` を呼ぶ
5. ロック取得失敗時は「スキップ扱い」で `200` or `202` を返す
6. ロック取得成功時だけ orchestrator を実行
7. 処理開始時点で `updateAnalysisStatus(..., EXTRACTING, step=extract)` を行う
8. 例外時は `FAILED` 更新してエラー JSON を返す

## 疑似コード
```ts
app.post('/tasks/analysis', async (c) => {
  const body = await c.req.json()
  const analysisId = body.analysis_id // API -> domain の変換
  if (!analysisId) return c.json({ error: { code: 'INVALID_INPUT' } }, 400)

  const lockOwner = `task_${Date.now()}`
  const lock = await repo.acquireAnalysisLock(analysisId, lockOwner)
  if (!lock.acquired) {
    return c.json({ accepted: false, analysis_id: analysisId, reason: 'already_processed_or_locked' }, 200)
  }

  try {
    await orchestrator.run(analysisId, { lockOwner })
    return c.json({ accepted: true, analysis_id: analysisId }, 202)
  } catch (err) {
    await repo.updateAnalysisStatus(analysisId, 'FAILED', 1, 'finalize', {
      code: 'WORKER_FAILED',
      messagePublic: 'analysis failed'
    })
    return c.json({ error: { code: 'WORKER_FAILED' } }, 500)
  } finally {
    await repo.releaseAnalysisLock(analysisId, lockOwner)
  }
})
```

## エラー方針
- `400`: `analysis_id` がない/形式不正
- `404`: analysis が存在しない
- `409` or `200`: すでに READY/FAILED またはロック中（冪等スキップ）
- `500`: 内部例外（Firestore/GCS/解析失敗）

## テスト観点
- 正常系: valid `analysis_id` で `accepted: true`
- 異常系: `analysis_id` なしで `400`
- 冪等: 同じ `analysis_id` を2回送って片方がスキップされる
- 例外: orchestrator 例外で `FAILED` 更新される

## 依存タスク
- BE-041（ロック）
- BE-042〜046（orchestrator 内で順次利用）

## 作業ログ
- 
